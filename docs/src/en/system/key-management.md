# Key Management

Zilp-Zalp uses a public key infrastructure (PKI) to encrypt data, authenticate actors to the backend, and sign requests that are published.

As with all systems, the security of the overall system depends crucially on the security of this PKI. Zilp-Zalp is designed to work with existing PKI systems. For demonstration purposes, the system also has its own PKI, but this should be replaced if possible in a real deployment of the system.

## Basic ideas

Health authorities, backend operators and, where applicable, operators of localities each have individual asymmetric key pairs for encrypting/decrypting and signing data. In addition, one or more root key pairs exist with which other keys in the system are certified and which serve as trust anchors in the backend and the web applications.
In order to make the overall system as robust as possible against the loss of keys, the following measures should be observed:

* The applicability and power of individual keys should be limited as much as possible in space and time.
* Private keys should only be generated on site and not "moved".

## Necessary keys

Zilp-Zalp requires the following key pairs during operation:

* For each backend instance, one or more root signature key pairs that certify other keys in the system and serve as trust anchors.
* For each health department, one or more key pairs (GA keys), each for encrypting/decrypting data and for signing data.
* For the global encryption of visit data, all health departments share a GÄ data key.
* Optional for operators one or more key pairs for signing data.

Root key pairs are generated by the backend operator and exchanged on a regular basis. Public root keys are delivered as configuration files with the web applications (to be independent of the backend itself).

GA key pairs are generated locally, public keys are sent over a trusted channel to the backend operator who signs them and stores them in the system.

GA key pairs can be rotated frequently, but in practice rotation that is faster than the average data retention time in the system makes little sense, since GAs must be able to decrypt data encrypted with previous GA keys during this period, and the corresponding keys must therefore still be kept together in the same location (this does not apply to signature keys).
In practice, 2-4 weeks can therefore be reasonable rotation periods for root and - GA keys. More frequent, e.g. daily, key changes as proposed in other systems often lead to key rotation running automatically (e.g. via API endpoints in the same system that publishes keys), which counteracts the security of such an exchange, at least in part.

The GA key should be changed frequently, for this a "Key Agreement" process between the GAs is necessary. This can be done by a GA providing other GAs each with a random value encrypted via the backend, this can be encrypted with the public data keys of the GAs and additionally signed by the sending GA. This random value is then locally combined with a common long-lived random value, and a key pair is deterministically derived from the resulting value. The shared long-lived random value must be securely shared over another channel in this case, but can be long-lived to keep the overhead low. By using a derivation mechanism instead of a direct key exchange, a private data key can be prevented from being compromised in case a GA data key is compromised.

To further reduce the risk of key loss, multiple GA keys can also be used to encrypt data. However, this would in turn require GAs to provide "administrative assistance" via the backend when decrypting data. Due to the large volume of data, this would require an automatic solution, which in turn would make a distribution of the keys obsolete.

In general, there is the problem that both signature - and data key pairs must be present in the GÄ web application. - For security reasons, however, it would make sense to separate these keys. Accordingly, the web application should possibly be split and protected via an "air-gap". Here, the public part would own the signature key, make requests to the backend, and receive data. The private part, on the other hand, would have the data key, decrypt the received data and process it. Whether such a separation makes sense must be weighed up.

## Risk analysis

The following sections describe risks that arise from the loss of private keys in the system.

### Loss of a private GÄ data key

If an attacker gains access to a private GÄ data key, he can use it to decrypt the visit data encrypted with the corresponding public key as well as to remove the external decryption of a user's contact data encrypted with the public key.
If he gains access to visit data of operators, he can use it to reconstruct the visit history of users.
If he also gains access to the contact data stored in the backend for this visit data, he can also decrypt it completely (since the key $K _ B$ is in the visit data).

### Loss of a private GÄ signing key

If an attacker gains access to a private GÄ signing key, he can use it to authenticate himself to the backend, retrieve data from there and make abusive requests. However, he cannot retrieve contact data from the backend without knowledge of $I _ D$ values. To obtain such $I _ D$ values, he can make requests for visit data. However, this also requires the presence of a GA data packet (under user control). To decrypt this, the attacker must also possess the associated private GA data key.

### Loss of a private root signing key

If an attacker gains access to a private root signing key, he can register his own key pairs in the system and make them appear trustworthy to all actors. He can thus, for example, cause actors to encrypt data with these keys and store it in the system.

### Compromise of system components

In both of the above scenarios, it is assumed that the attacker has only gained access to key material, but has not compromised any system components apart from this. These scenarios are described in more detail in the [risk analysis]({{'analyses.risks'|href}}) and are therefore left out here.
